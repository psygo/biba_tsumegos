\documentclass{book}

\usepackage[portuguese]{babel}

\usepackage[paperheight   = 5.2in, % ~A6
            paperwidth    = 4.1in,
            bindingoffset = 0.2in,
            left          = 0.2in,
            right         = 0.3in,
            top           = 0.7in,
            bottom        = 0.6in,
            footskip      = 0.25in]{geometry}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{math}

\usepackage[labelformat = simple]{subfig}
\renewcommand{\thesubfigure}{\relax} 

\usepackage{listofitems}
\usepackage{ifthen}
\usepackage{lmodern}

\usepackage{./diagrams}

%-----------------------------------------------------------
% Drawing Stones

% From [this answer by @DavidCarlisle](https://tex.stackexchange.com/a/708876/64441).
\newcommand\notwhite{black}
\newcommand\notblack{white}

% From [this answer by @Skillmon](https://tex.stackexchange.com/a/708866/64441).
\ExplSyntaxOn
  \cs_new_eq:NN \ifStrEq \str_if_eq:nnTF
\ExplSyntaxOff

% From [this answer by @DavidCarlisle](https://tex.stackexchange.com/a/708893/64441).
\ExplSyntaxOn
  \cs_generate_variant:Nn \int_from_alph:n {e}

  \NewExpandableDocumentCommand{\stringToCoordX}{ m }{
    \int_from_alph:e { \use_i:nn #1 }
  }
  \NewExpandableDocumentCommand{\stringToCoordY}{ m }{
    \boardSize + 1 - ~\int_from_alph:e { \use_ii:nn #1 }
  }
\ExplSyntaxOff

\newcommand{\setCoords}[1]{
  \pgfmathsetmacro{\x}{\stringToCoordX{#1} - 1}
  \pgfmathsetmacro{\y}{\stringToCoordY{#1} - 1}
}

\newcommand{\drawStoneFromSgfCoords}[2]{%
  \setCoords{#2}
  
  \pgfmathsetmacro{\stoneRadius}{\step * \ifStrEq{black}{#1}{0.99}{0.91} / 2}
  \pgfmathsetmacro{\outlineWidth}{\step * 1.15}

  \draw[
    draw = \UseName{not#1},
    fill = #1,
    minimum size = \step * 1cm,
    line width = \outlineWidth
  ]
    (\x * \step, \y * \step)
    circle [radius = \stoneRadius];
}


\newcommand{\drawMoveFromSgfCoords}[2]{
  \expandafter\xdef\csname thecolorat#2\endcsname{#1}% SAVE COLOR AT #2
  \drawStoneFromSgfCoords{#1}{#2}
  \textLabel{#1}{#2}{\themoveCounter}

  \stepMoveCounter
}

\newcounter{moveCounter}
\setcounter{moveCounter}{1}

\newcommand{\stepMoveCounter}{
  \stepcounter{moveCounter}
}

%-----------------------------------------------------------
% Labels

\newcommand\StoneColor[1]{% COMPLEMENTARY COLOR OF REFERENCED STONE
  \ifcsname thecolorat#1\endcsname
    \csname thecolorat#1\endcsname
  \else
    white% COMPLEMENT OF DEFAULT LABEL COLOR WHEN NOT ATOP EXISTING STONE
  \fi
}

\newcommand{\textLabel}[3]{%
  \setCoords{#2}%
  \draw (\x * \step, \y * \step) 
  node[
    color = -\StoneColor{#2},
    fill = \StoneColor{#2},
    inner sep=1pt,
    font  = \small\sffamily
  ] {#3};
}

\newcommand{\crossLabel}[2]{
  \setCoords{#2}
  \draw (\x * \step, \y * \step) 
  node[
    color = -\StoneColor{#2},
    fill = \StoneColor{#2},
    inner sep=1pt
  ] {$\times$};
}

\newcommand{\triangleLabel}[2]{
  \setCoords{#2}
  \draw (\x * \step, \y * \step) 
    node[
      isosceles triangle,
      draw                          = #1,
      line width                    = 0.5mm,
      color                         = -\StoneColor{#2},
      fill                          = -\StoneColor{#2},
      minimum height                = \step * 10,
      minimum width                 = \step * 10,
      rotate                        = 90,
      isosceles triangle apex angle = 60,
      inner sep                     = 0pt,
    ] {};
}

\newcommand{\squareLabel}[2]{
  \setCoords{#2}

  \draw (\x * \step, \y * \step) 
    node[
      draw         = #1,
      line width   = 0.5mm,
      color        = -\StoneColor{#2},
      fill         = -\StoneColor{#2},
      minimum size = \step * 10,
      inner sep    = 0pt,
    ] {};
}

\newcommand{\circleLabel}[2]{
  \setCoords{#2}

  \draw[
    draw         = #1,
    line width   = 0.5mm,
    color        = -\StoneColor{#2},
    fill         = -\StoneColor{#2},
    inner sep    = 0pt,
  ] (\x * \step, \y * \step) 
    circle[radius = \step / 4];
}

%-----------------------------------------------------------
% SGF Parser

% From [this answer by @StevenB.Segletes](https://tex.stackexchange.com/a/709014/64441).
\long\def\Firstof#1#2\endFirstof{#1}

\newcommand\thecolorofB{black}
\newcommand\thecolorofAB{black}
\newcommand\thecolorofW{white}
\newcommand\thecolorofAW{white}
\newcommand\thecolorofMA{white}
\newcommand\thecolorofCR{white}
\newcommand\thecolorofTR{white}
\newcommand\thecolorofSQ{white}
\newcommand\thecolorofLB{white}

\long\def\Keytypeof#1{\csname thekeytypeof#1\endcsname}

\newcommand\thekeytypeofB{M}  % black move
\newcommand\thekeytypeofAB{A} % added (edited) black stone
\newcommand\thekeytypeofW{M}  % white move
\newcommand\thekeytypeofAW{A} % added (edited) white stone
\newcommand\thekeytypeofMA{K} % cross (mark) label
\newcommand\thekeytypeofCR{C} % circle label
\newcommand\thekeytypeofTR{T} % triangle label
\newcommand\thekeytypeofSQ{S} % square label
\newcommand\thekeytypeofLB{L} % text label

\newcommand{\parseSgf}[1]{%
  \setsepchar{(||)/;/]/[/:}%
  \readlist*\Z{#1}%

  \foreachitem \Branch \in \Z[]{%
  \foreachitem \Group \in \Z[\Branchcnt]{%
    \foreachitem \Key \in \Z[\Branchcnt, \Groupcnt]{%
     \if\relax\Key\relax% IF BLANK KEY & VALUE, SKIP
     \else
      \itemtomacro\Z[\Branchcnt, \Groupcnt, \Keycnt, 1]\KeyName
      \if\relax\KeyName\relax% IF VALUE, BUT NO KEYNAME, USE RECENT KEYNAME
        \let\KeyName\MostRecentKeyname
      \else
        \xdef\MostRecentKeyname{\KeyName}%
      \fi
      \itemtomacro\Z[\Branchcnt, \Groupcnt, \Keycnt, 2, 1]\KeyValue

      \edef\tmp{{\csname thecolorof\KeyName\endcsname}{\KeyValue}}%

      \if\Keytypeof\KeyName M
        \expandafter\drawMoveFromSgfCoords\tmp
      \fi
      \if\Keytypeof\KeyName A
        \expandafter\drawStoneFromSgfCoords\tmp
      \fi
      \if\Keytypeof\KeyName K
        \expandafter\crossLabel\tmp
      \fi
      \if\Keytypeof\KeyName C
        \expandafter\circleLabel\tmp
      \fi
      \if\Keytypeof\KeyName T
        \expandafter\triangleLabel\tmp
      \fi
      \if\Keytypeof\KeyName S
        \expandafter\squareLabel\tmp
      \fi
      \if\Keytypeof\KeyName L
        \expandafter\textLabel\tmp{\Z[\Branchcnt, \Groupcnt, \Keycnt, 2, 2]} 
      \fi
     \fi
    }
  }%
  }%
}

%-----------------------------------------------------------
% SGFs

\def\sgfE{(
  ;GM[1]FF[4]CA[UTF-8]AP[CGoban:3]ST[2]RU[Japanese]SZ[19]KM[6.50]DT[2023-12-25]
  ;B[pd]
  ;W[dd]
  ;B[dp]
  ;W[pp]
  ;AW[ji][jn][kn][ln]AB[jj][jm][km]TR[jp][kp][lp]PL[B]
  ;B[jq]CR[pp]LB[dd:A][jd:C][pd:B]TR[jj]SQ[ji]MA[dp]
)}

%-----------------------------------------------------------
% Setup

% \pgfmathsetmacro{\boardDimension}{10}
% \pgfmathsetmacro{\boardSize}{19}
% \pgfmathsetmacro{\step}{\boardDimension / (\boardSize - 1)}

%-----------------------------------------------------------
% Grid

\newcommand{\calculateStep}{
  \pgfmathsetmacro{\step}{\boardDimension / (\boardSize - 1)} % chktex 1
}

% From [this answer by @UlrichDiez](https://tex.stackexchange.com/a/709341/64441).
\pgfkeys{%
  %---------------------------------------------------------
  /phili/goGrid/.cd, 
    %-------------------------------------------------------
    % Dimensions
    board dimension/.store in    = \boardDimension,
    board dimension              = 10cm,
    board size/.store in         = \boardSize,
    board size                   = 19,
    %-------------------------------------------------------
    % Outline
    outline line width/.store in = \boardOutlineWidth,
    outline line width           = 0.7mm,
  %---------------------------------------------------------
  /phili/goban/.search also={/phili/goGrid},
  /phili/goban/.cd,  
    %-------------------------------------------------------
    % Scale
    scale/.store in              = \scale,
    scale                        = 1,
    %-------------------------------------------------------
    % Partial Boards
    horizontal clip start/.store in = \horClipStart,
    horizontal clip start           = -1,
    horizontal clip end/.store in   = \horClipEnd, % This is more like the width?
    horizontal clip end             = -1,
    vertical clip start/.store in   = \verClipStart,
    vertical clip start             = -1,
    vertical clip end/.store in     = \verClipEnd, % This is more like the height?
    vertical clip end               = -1,
  %---------------------------------------------------------
}

% Parameters
%
% - `board dimension` (in cm)
% - `board size` (square)
% 
% Example: A 19x19 board with size 10cm x 10cm:
%
% ```tex
% \goGrid[board dimension    = 10,
%         board size         = 9,
%         scale              = 1,
%         outline line width = 0.5mm]
% ```
\newcommand{\goGrid}[1][]{
  \pgfkeys{/phili/goGrid/.cd, #1}

  \calculateStep

  \draw[step=\step] (0, 0) grid
    (\boardDimension, \boardDimension);
  
  \boardOutline{\boardDimension}

  \drawHoshis
}

% Reference: [Drawing a Non-Jagged Grid Outline](https://tex.stackexchange.com/q/709298/64441)
%
% Parameters
%
% 1: dimension (in cm)
% 
% Example: `\boardOutline{10}`
\newcommand{\boardOutline}[1]{
  \draw[step       = #1,
        line width = \boardOutlineWidth,
        line cap   = rect] 
    (0, 0) grid (#1, #1);
}

% Example: A 19x19 board with size 10cm x 10cm: `\drawHoshis`
\newcommand{\drawHoshis}{
  \tikzmath{
    \hoshiRadius = \step * 0.125;
    %
    \centerHoshi = ceil(\boardSize / 2);
    %
    int \hoshiDistance;
    if \boardSize<12 then {
      \hoshiDistance = 3;
    } else {
      \hoshiDistance = 4;
    };
    %
    \hoshiComplement = \boardSize - \hoshiDistance + 1;
  }

  \drawCenterHoshi
  \drawCornerHoshis
  \ifnum\boardSize>6\relax
    \drawCornerHoshis
  \fi
  \ifthenelse{\isodd{\boardSize}}{
    \ifnum\boardSize>13\relax
      \drawSideHoshis
    \fi
  }{}
}

\newcommand{\drawCenterHoshi}{
  \pgfmathsetmacro{\centerHoshiCoord}{(\centerHoshi - 1) * \step}

  \filldraw (\centerHoshiCoord, \centerHoshiCoord)
    circle [radius=\hoshiRadius];
}

\newcommand{\drawCornerHoshis}{
  \def\cornerHoshisArray{%
    {\hoshiDistance, \hoshiDistance},%
    {\hoshiComplement, \hoshiDistance},%
    {\hoshiDistance, \hoshiComplement },%
    {\hoshiComplement, \hoshiComplement}%
  }

  \loopOverHoshis{\cornerHoshisArray}
}

\newcommand{\loopOverHoshis}[1]{
  \foreach \sloc in #1 {
    \pgfmathsetmacro{\hoshiCoordX}{\step * ({\sloc}[0] - 1)}
    \pgfmathsetmacro{\hoshiCoordY}{\step * ({\sloc}[1] - 1)}

    \filldraw (\hoshiCoordX, \hoshiCoordY)
      circle [radius=\hoshiRadius];
  }
}

\newcommand{\drawSideHoshis}{
  \def\sideHoshisArray{%
    {\hoshiDistance, \centerHoshi},%
    {\centerHoshi, \hoshiComplement},%
    {\centerHoshi, \hoshiDistance},%
    {\hoshiComplement, \centerHoshi}%
  }    

  \loopOverHoshis{\sideHoshisArray}
}

%-----------------------------------------------------------

% \usepackage{./goban/goban}
\usepackage{catchfile}

% From [this question/answer](https://tex.stackexchange.com/a/726141/64441)
\newcommand\parseSgfFile[1]{%
  \CatchFileDef{\mysgf}{#1}{}%
  \parseSgf{\mysgf}% 
}

%-----------------------------------------------------------
% Goban Env

\newcommand{\partialBoardClipping}{
  \ifthenelse{
    \equal{\horClipStart}{-1} \AND
    \equal{\horClipEnd}{-1} \AND
    \equal{\verClipStart}{-1} \AND
    \equal{\verClipEnd}{-1}
  }{}{
    \tikzmath{
      \horStart = (-1.5 + \horClipStart) * \step;
      \horEnd = (\horClipEnd) * \step;
      \verStart = (-1.5 + \verClipStart) * \step;
      \verEnd = (\verClipEnd) * \step;
    }

    \clip (\horStart, \verStart) rectangle 
          (\horEnd, \verEnd);
  }
}

\newenvironment{goban}[1][]{
  \pgfkeys{/phili/goban/.cd, #1}

  \begin{tikzpicture}[scale = \scale, transform shape]
    \calculateStep

    \partialBoardClipping

    \goGrid
}{
    \setcounter{moveCounter}{1}
  \end{tikzpicture}
}

%-----------------------------------------------------------

\begin{document}
  % \begin{tikzpicture}
  %   % \draw[step=\step] (0, 0) grid (10, 10);
  %   \goGrid[board dimension    = 10,
  %           board size         = 19,
  %           % scale              = 1,
  %           outline line width = 0.5mm]


  %   \parseSgfFile{sgf/test.sgf}
    
  %   % \textLabel{white}{ab}{A}
  %   % \triangleLabel{black}{ac}
  %   % \squareLabel{black}{ad}
  %   % \circleLabel{black}{ae}
  %   % \crossLabel{white}{af}
  % \end{tikzpicture}
  
  % \begin{figure}[t]
  %   \centering

  %   \begin{goban}[board dimension       = 8,
  %                 board size            = 19,
  %                 scale                 = 1,
  %                 outline line width    = 0.4mm,
  %                 horizontal clip start = 11,
  %                 horizontal clip end   = 19,
  %                 vertical clip start   = 11,
  %                 vertical clip end     = 19]
  %     \parseSgfFile{sgf/test.sgf}
  %   \end{goban}
  % \end{figure}

  \problemDiagrams
  \answerDiagrams%
    {A captura da pedra branca configura uma forma chamada \emph{ponnuki}, que é o número mínimo de pedras para se capturar uma pedra adversária, quando ela não está nem no canto e nem na borda. (Note que a pedra branca será retirada do tabuleiro.)}%
    {Ao escapar com esta pedra, Branco vai de 1 liberdade para 3, o que é bastante eficiente, isto é, 2 liberdades por movimento. Em lutas, liberdades são um bem crucial. E, desta forma, Branco também expõe os cortes \textsf{A} e \textsf{B} no exterior preto.}%
\end{document}